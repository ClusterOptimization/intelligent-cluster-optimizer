package gitops

import (
	"fmt"
	"strings"

	"gopkg.in/yaml.v2"
)

// DefaultHelmGenerator is the default implementation of HelmGenerator
type DefaultHelmGenerator struct{}

// NewHelmGenerator creates a new Helm values generator
func NewHelmGenerator() HelmGenerator {
	return &DefaultHelmGenerator{}
}

// GenerateValues generates Helm values for recommendations
func (g *DefaultHelmGenerator) GenerateValues(recommendations []ResourceRecommendation) (string, error) {
	if len(recommendations) == 0 {
		return "", fmt.Errorf("no recommendations provided")
	}

	values := make(HelmValues)

	for _, rec := range recommendations {
		if err := validateRecommendation(rec); err != nil {
			return "", fmt.Errorf("invalid recommendation for %s/%s: %w", rec.Namespace, rec.Name, err)
		}

		// Build the path for this recommendation
		// Common Helm pattern: <workloadName>.resources.requests.cpu
		workloadKey := sanitizeHelmKey(rec.Name)

		if _, exists := values[workloadKey]; !exists {
			values[workloadKey] = make(map[string]interface{})
		}

		workloadValues := values[workloadKey].(map[string]interface{})

		// Set resources
		if _, exists := workloadValues["resources"]; !exists {
			workloadValues["resources"] = make(map[string]interface{})
		}

		resources := workloadValues["resources"].(map[string]interface{})

		// Set requests
		if _, exists := resources["requests"]; !exists {
			resources["requests"] = make(map[string]interface{})
		}

		requests := resources["requests"].(map[string]interface{})
		requests["cpu"] = formatCPU(rec.RecommendedCPU)
		requests["memory"] = formatMemory(rec.RecommendedMemory)

		// Set limits if requested
		if rec.SetLimits {
			if _, exists := resources["limits"]; !exists {
				resources["limits"] = make(map[string]interface{})
			}

			limits := resources["limits"].(map[string]interface{})
			limits["cpu"] = formatCPU(rec.RecommendedCPU)
			limits["memory"] = formatMemory(rec.RecommendedMemory)
		}

		// Add metadata if confidence is available
		if rec.Confidence > 0 {
			if _, exists := workloadValues["optimizer"]; !exists {
				workloadValues["optimizer"] = make(map[string]interface{})
			}
			optimizer := workloadValues["optimizer"].(map[string]interface{})
			optimizer["confidence"] = fmt.Sprintf("%.1f%%", rec.Confidence)
			if rec.Reason != "" {
				optimizer["reason"] = rec.Reason
			}
		}
	}

	// Convert to YAML
	yamlBytes, err := yaml.Marshal(values)
	if err != nil {
		return "", fmt.Errorf("failed to marshal values to YAML: %w", err)
	}

	// Add header comment
	header := "# Generated by Intelligent Cluster Optimizer\n# This file contains resource recommendations\n\n"
	return header + string(yamlBytes), nil
}

// MergeValues merges new values with existing values
func (g *DefaultHelmGenerator) MergeValues(existing, new HelmValues) (HelmValues, error) {
	if existing == nil {
		return new, nil
	}
	if new == nil {
		return existing, nil
	}

	result := make(HelmValues)

	// Copy existing values
	for k, v := range existing {
		result[k] = v
	}

	// Merge new values (deep merge)
	for k, v := range new {
		if existingVal, exists := result[k]; exists {
			// If both are maps, merge recursively
			if existingMap, ok := existingVal.(map[string]interface{}); ok {
				if newMap, ok := v.(map[string]interface{}); ok {
					merged, err := g.MergeValues(existingMap, newMap)
					if err != nil {
						return nil, err
					}
					result[k] = merged
					continue
				}
			}
		}
		// Otherwise, overwrite
		result[k] = v
	}

	return result, nil
}

// sanitizeHelmKey sanitizes a string to be a valid Helm values key
func sanitizeHelmKey(s string) string {
	// Replace invalid characters with underscores
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, ".", "_")
	return s
}

// GenerateValuesWithPath generates Helm values with custom path structure
func GenerateValuesWithPath(rec ResourceRecommendation, path []string) (HelmValues, error) {
	if err := validateRecommendation(rec); err != nil {
		return nil, err
	}

	resources := map[string]interface{}{
		"requests": map[string]string{
			"cpu":    formatCPU(rec.RecommendedCPU),
			"memory": formatMemory(rec.RecommendedMemory),
		},
	}

	if rec.SetLimits {
		resources["limits"] = map[string]string{
			"cpu":    formatCPU(rec.RecommendedCPU),
			"memory": formatMemory(rec.RecommendedMemory),
		}
	}

	// Build nested structure from path
	result := make(HelmValues)
	current := result

	for i, key := range path {
		if i == len(path)-1 {
			// Last key, set the resources
			current[key] = resources
		} else {
			// Intermediate key, create nested map
			current[key] = make(map[string]interface{})
			current = current[key].(map[string]interface{})
		}
	}

	return result, nil
}
