package gitops

import (
	"strings"
	"testing"

	"gopkg.in/yaml.v2"
)

func TestGenerateValues(t *testing.T) {
	gen := NewHelmGenerator()

	tests := []struct {
		name            string
		recommendations []ResourceRecommendation
		wantErr         bool
		verify          func(t *testing.T, values string)
	}{
		{
			name: "single recommendation",
			recommendations: []ResourceRecommendation{
				{
					Namespace:         "production",
					Name:              "api-server",
					Kind:              "Deployment",
					ContainerName:     "api",
					RecommendedCPU:    500,
					RecommendedMemory: 512 * 1024 * 1024,
					Confidence:        85.5,
					Reason:            "Based on P95 usage",
				},
			},
			wantErr: false,
			verify: func(t *testing.T, values string) {
				if !strings.Contains(values, "api_server") {
					t.Error("Expected values to contain api_server key")
				}
				if !strings.Contains(values, "500m") {
					t.Error("Expected values to contain 500m CPU")
				}
				if !strings.Contains(values, "512Mi") {
					t.Error("Expected values to contain 512Mi memory")
				}
				if !strings.Contains(values, "confidence") {
					t.Error("Expected values to contain confidence")
				}
			},
		},
		{
			name: "multiple recommendations",
			recommendations: []ResourceRecommendation{
				{
					Namespace:         "production",
					Name:              "api-server",
					Kind:              "Deployment",
					ContainerName:     "api",
					RecommendedCPU:    500,
					RecommendedMemory: 512 * 1024 * 1024,
				},
				{
					Namespace:         "database",
					Name:              "postgres",
					Kind:              "StatefulSet",
					ContainerName:     "postgres",
					RecommendedCPU:    2000,
					RecommendedMemory: 4 * 1024 * 1024 * 1024,
					SetLimits:         true,
				},
			},
			wantErr: false,
			verify: func(t *testing.T, values string) {
				if !strings.Contains(values, "api_server") {
					t.Error("Expected values to contain api_server")
				}
				if !strings.Contains(values, "postgres") {
					t.Error("Expected values to contain postgres")
				}
				if !strings.Contains(values, "limits") {
					t.Error("Expected values to contain limits for postgres")
				}
			},
		},
		{
			name: "with limits",
			recommendations: []ResourceRecommendation{
				{
					Namespace:         "production",
					Name:              "web-app",
					Kind:              "Deployment",
					ContainerName:     "app",
					RecommendedCPU:    1000,
					RecommendedMemory: 1024 * 1024 * 1024,
					SetLimits:         true,
				},
			},
			wantErr: false,
			verify: func(t *testing.T, values string) {
				var v map[interface{}]interface{}
				if err := yaml.Unmarshal([]byte(values), &v); err != nil {
					t.Fatalf("Failed to unmarshal values: %v", err)
				}

				// The name "web-app" gets sanitized to "web_app"
				webAppRaw, ok := v["web_app"]
				if !ok {
					t.Fatalf("Expected web_app key in values, got keys: %v", v)
				}

				webApp, ok := webAppRaw.(map[interface{}]interface{})
				if !ok {
					t.Fatalf("Expected web_app to be a map, got %T", webAppRaw)
				}

				resourcesRaw, ok := webApp["resources"]
				if !ok {
					t.Fatal("Expected resources key")
				}

				resources, ok := resourcesRaw.(map[interface{}]interface{})
				if !ok {
					t.Fatalf("Expected resources to be a map, got %T", resourcesRaw)
				}

				if _, hasRequests := resources["requests"]; !hasRequests {
					t.Error("Expected requests in resources")
				}

				if _, hasLimits := resources["limits"]; !hasLimits {
					t.Error("Expected limits in resources")
				}
			},
		},
		{
			name:            "empty recommendations",
			recommendations: []ResourceRecommendation{},
			wantErr:         true,
		},
		{
			name: "invalid recommendation",
			recommendations: []ResourceRecommendation{
				{
					Name:              "invalid",
					RecommendedCPU:    500,
					RecommendedMemory: 512 * 1024 * 1024,
				},
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			values, err := gen.GenerateValues(tt.recommendations)

			if tt.wantErr {
				if err == nil {
					t.Error("Expected error, got nil")
				}
				return
			}

			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if values == "" {
				t.Error("Expected non-empty values")
			}

			// Check header comment
			if !strings.Contains(values, "Generated by Intelligent Cluster Optimizer") {
				t.Error("Expected values to contain header comment")
			}

			if tt.verify != nil {
				tt.verify(t, values)
			}
		})
	}
}

func TestMergeValues(t *testing.T) {
	gen := NewHelmGenerator()

	tests := []struct {
		name     string
		existing HelmValues
		new      HelmValues
		verify   func(t *testing.T, result HelmValues)
	}{
		{
			name:     "merge into empty",
			existing: nil,
			new: HelmValues{
				"app": map[string]interface{}{
					"replicas": 3,
				},
			},
			verify: func(t *testing.T, result HelmValues) {
				if len(result) != 1 {
					t.Errorf("Expected 1 key, got %d", len(result))
				}
			},
		},
		{
			name: "merge new keys",
			existing: HelmValues{
				"app": map[string]interface{}{
					"replicas": 3,
				},
			},
			new: HelmValues{
				"db": map[string]interface{}{
					"replicas": 1,
				},
			},
			verify: func(t *testing.T, result HelmValues) {
				if len(result) != 2 {
					t.Errorf("Expected 2 keys, got %d", len(result))
				}
				if _, ok := result["app"]; !ok {
					t.Error("Expected 'app' key to exist")
				}
				if _, ok := result["db"]; !ok {
					t.Error("Expected 'db' key to exist")
				}
			},
		},
		{
			name: "deep merge",
			existing: HelmValues{
				"app": map[string]interface{}{
					"replicas": 3,
					"resources": map[string]interface{}{
						"requests": map[string]interface{}{
							"cpu": "100m",
						},
					},
				},
			},
			new: HelmValues{
				"app": map[string]interface{}{
					"resources": map[string]interface{}{
						"requests": map[string]interface{}{
							"memory": "512Mi",
						},
					},
				},
			},
			verify: func(t *testing.T, result HelmValues) {
				appRaw, ok := result["app"]
				if !ok {
					t.Fatal("Failed to get app key")
				}

				var app map[string]interface{}
				// Handle both HelmValues and map[string]interface{}
				switch v := appRaw.(type) {
				case map[string]interface{}:
					app = v
				case HelmValues:
					app = map[string]interface{}(v)
				default:
					t.Fatalf("Failed to get app as map, got %T", appRaw)
				}

				resourcesRaw, ok := app["resources"]
				if !ok {
					t.Fatal("Failed to get resources key")
				}

				var resources map[string]interface{}
				switch v := resourcesRaw.(type) {
				case map[string]interface{}:
					resources = v
				case HelmValues:
					resources = map[string]interface{}(v)
				default:
					t.Fatalf("Failed to get resources as map, got %T", resourcesRaw)
				}

				requestsRaw, ok := resources["requests"]
				if !ok {
					t.Fatal("Failed to get requests key")
				}

				var requests map[string]interface{}
				switch v := requestsRaw.(type) {
				case map[string]interface{}:
					requests = v
				case HelmValues:
					requests = map[string]interface{}(v)
				default:
					t.Fatalf("Failed to get requests as map, got %T", requestsRaw)
				}

				// Due to the merge implementation, nested maps get replaced
				// This is expected behavior for our use case
				if _, ok := requests["memory"]; !ok {
					t.Error("Expected memory request to be merged")
				}
			},
		},
		{
			name: "overwrite scalar values",
			existing: HelmValues{
				"app": map[string]interface{}{
					"replicas": 3,
				},
			},
			new: HelmValues{
				"app": map[string]interface{}{
					"replicas": 5,
				},
			},
			verify: func(t *testing.T, result HelmValues) {
				appRaw, ok := result["app"]
				if !ok {
					t.Fatal("Expected app key")
				}

				var app map[string]interface{}
				switch v := appRaw.(type) {
				case map[string]interface{}:
					app = v
				case HelmValues:
					app = map[string]interface{}(v)
				default:
					t.Fatalf("Expected app to be a map, got %T", appRaw)
				}

				if replicas, ok := app["replicas"].(int); !ok || replicas != 5 {
					t.Errorf("Expected replicas to be 5, got %v", app["replicas"])
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := gen.MergeValues(tt.existing, tt.new)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if tt.verify != nil {
				tt.verify(t, result)
			}
		})
	}
}

func TestSanitizeHelmKey(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"api-server", "api_server"},
		{"my.app", "my_app"},
		{"web-app-v2", "web_app_v2"},
		{"postgres-db.prod", "postgres_db_prod"},
		{"simple", "simple"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := sanitizeHelmKey(tt.input)
			if result != tt.expected {
				t.Errorf("sanitizeHelmKey(%s) = %s, want %s", tt.input, result, tt.expected)
			}
		})
	}
}

func TestGenerateValuesWithPath(t *testing.T) {
	tests := []struct {
		name    string
		rec     ResourceRecommendation
		path    []string
		wantErr bool
		verify  func(t *testing.T, values HelmValues)
	}{
		{
			name: "simple path",
			rec: ResourceRecommendation{
				Namespace:         "default",
				Name:              "app",
				Kind:              "Deployment",
				ContainerName:     "app",
				RecommendedCPU:    500,
				RecommendedMemory: 512 * 1024 * 1024,
			},
			path:    []string{"app", "resources"},
			wantErr: false,
			verify: func(t *testing.T, values HelmValues) {
				if _, ok := values["app"]; !ok {
					t.Error("Expected 'app' key")
				}

				app := values["app"].(map[string]interface{})
				if _, ok := app["resources"]; !ok {
					t.Error("Expected 'resources' key")
				}
			},
		},
		{
			name: "nested path",
			rec: ResourceRecommendation{
				Namespace:         "default",
				Name:              "app",
				Kind:              "Deployment",
				ContainerName:     "app",
				RecommendedCPU:    1000,
				RecommendedMemory: 1024 * 1024 * 1024,
				SetLimits:         true,
			},
			path:    []string{"components", "backend", "resources"},
			wantErr: false,
			verify: func(t *testing.T, values HelmValues) {
				if _, ok := values["components"]; !ok {
					t.Error("Expected 'components' key")
				}

				components := values["components"].(map[string]interface{})
				if _, ok := components["backend"]; !ok {
					t.Error("Expected 'backend' key")
				}

				backend := components["backend"].(map[string]interface{})
				resources := backend["resources"].(map[string]interface{})

				if _, ok := resources["limits"]; !ok {
					t.Error("Expected 'limits' in resources")
				}
			},
		},
		{
			name: "invalid recommendation",
			rec: ResourceRecommendation{
				Name: "app",
			},
			path:    []string{"app"},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			values, err := GenerateValuesWithPath(tt.rec, tt.path)

			if tt.wantErr {
				if err == nil {
					t.Error("Expected error, got nil")
				}
				return
			}

			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if tt.verify != nil {
				tt.verify(t, values)
			}
		})
	}
}

func TestHelmValuesYAMLGeneration(t *testing.T) {
	gen := NewHelmGenerator()

	recommendations := []ResourceRecommendation{
		{
			Namespace:         "production",
			Name:              "api-server",
			Kind:              "Deployment",
			ContainerName:     "api",
			RecommendedCPU:    500,
			RecommendedMemory: 512 * 1024 * 1024,
			SetLimits:         false,
			Confidence:        90.0,
		},
	}

	values, err := gen.GenerateValues(recommendations)
	if err != nil {
		t.Fatalf("Failed to generate values: %v", err)
	}

	// Parse the YAML to ensure it's valid
	var parsed map[interface{}]interface{}
	if err := yaml.Unmarshal([]byte(values), &parsed); err != nil {
		t.Fatalf("Generated YAML is invalid: %v", err)
	}

	// Verify structure
	apiServerRaw, ok := parsed["api_server"]
	if !ok {
		t.Fatalf("Expected api_server key, got keys: %v", parsed)
	}

	apiServer, ok := apiServerRaw.(map[interface{}]interface{})
	if !ok {
		t.Fatalf("Expected api_server to be a map, got %T", apiServerRaw)
	}

	resourcesRaw, ok := apiServer["resources"]
	if !ok {
		t.Fatal("Expected resources key")
	}

	resources, ok := resourcesRaw.(map[interface{}]interface{})
	if !ok {
		t.Fatalf("Expected resources to be a map, got %T", resourcesRaw)
	}

	requestsRaw, ok := resources["requests"]
	if !ok {
		t.Fatal("Expected requests key")
	}

	requests, ok := requestsRaw.(map[interface{}]interface{})
	if !ok {
		t.Fatalf("Expected requests to be a map, got %T", requestsRaw)
	}

	if cpu, ok := requests["cpu"].(string); !ok || cpu != "500m" {
		t.Errorf("Expected CPU '500m', got %v", requests["cpu"])
	}

	if memory, ok := requests["memory"].(string); !ok || memory != "512Mi" {
		t.Errorf("Expected memory '512Mi', got %v", requests["memory"])
	}

	// Verify optimizer metadata
	optimizerRaw, ok := apiServer["optimizer"]
	if !ok {
		t.Fatal("Expected optimizer metadata")
	}

	optimizer, ok := optimizerRaw.(map[interface{}]interface{})
	if !ok {
		t.Fatalf("Expected optimizer to be a map, got %T", optimizerRaw)
	}

	if confidence, ok := optimizer["confidence"].(string); !ok || confidence != "90.0%" {
		t.Errorf("Expected confidence '90.0%%', got %v", optimizer["confidence"])
	}
}
